(self.webpackChunksite=self.webpackChunksite||[]).push([[8546],{4408:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-6e6d92cc",path:"/guide/advanced/proxy.html",title:"本地 Proxy 方案",lang:"zh-CN",frontmatter:{title:"本地 Proxy 方案",order:12},excerpt:"",headers:[{level:2,title:"访问前端调试地址代理后端接口",slug:"访问前端调试地址代理后端接口",children:[{level:3,title:"配置 proxy 字段",slug:"配置-proxy-字段",children:[]},{level:3,title:"匹配规则",slug:"匹配规则",children:[]},{level:3,title:"请求示例",slug:"请求示例",children:[]}]},{level:2,title:"访问后端地址代理前端资源",slug:"访问后端地址代理前端资源",children:[]}],filePathRelative:"guide/advanced/proxy.md",git:{updatedTime:162142938e4,contributors:[]}}},3859:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>k});var e=a(6252);const t=(0,e.uE)('<p>本地开发场景下，访问页面的 url 是 <code>http://127.0.0.1:3333</code>，但是后端接口可能是其他 ip、域名或端口，此时就会产生跨域问题，导致无法调试，针对这个问题推荐两种代理方式：</p><ol><li>访问前端页面地址代理后端接口：访问 <code>npm start</code> 启动的页面地址 <code>http://127.0.0.1:3333</code>，然后将页面中发出的请求代理到前端调试服务（devServer），然后通过调试服务向后端发起实际的接口请求</li><li>访问后端页面地址代理前端资源：访问后端服务提供的页面 url 地址，此时页面中通常加载的都不是本地调试的前端资源，因此无法联调，需要通过工具进行资源地址的代理</li></ol><table><thead><tr><th>维度\\方案</th><th>访问前端页面地址代理后端接口</th><th>访问后端地址代理前端资源</th></tr></thead><tbody><tr><td>浏览器中打开的页面地址</td><td>http://127.0.0.1:3333</td><td>用户真实访问的地址如：https://taobao.com</td></tr><tr><td>是否支持接口鉴权</td><td>不支持（本地页面没有用户信息）</td><td>支持</td></tr><tr><td>是否依赖后端服务</td><td>弱依赖（只有接口）</td><td>强依赖（页面+接口）</td></tr></tbody></table><p>两种方式的优缺点如上，开发者按需选择一个即可。接下来介绍两种方案具体的操作方式。</p><h2 id="访问前端调试地址代理后端接口"><a class="header-anchor" href="#访问前端调试地址代理后端接口">#</a> 访问前端调试地址代理后端接口</h2><h3 id="配置-proxy-字段"><a class="header-anchor" href="#配置-proxy-字段">#</a> 配置 proxy 字段</h3><p>在 <code>build.json</code> 中配置 <code>proxy</code> 字段：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token string">&quot;proxy&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n\t  <span class="token string">&quot;/api&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token string">&quot;enable&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token string">&quot;target&quot;</span><span class="token operator">:</span> <span class="token string">&quot;http://127.0.0.1:6001&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',8),p=(0,e.Uk)("页面中发出的所有 "),l=(0,e.Wm)("code",null,"/api",-1),r=(0,e.Uk)(" 开头的接口都会被代理到 "),o=(0,e.Wm)("code",null,"http://127.0.0.1:6001",-1),c=(0,e.Uk)("。proxy 完整的配置项请参考 "),i={href:"https://github.com/chimurai/http-proxy-middleware",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Uk)("http-proxy-middleware"),d=(0,e.Uk)("。"),h=(0,e.uE)('<h3 id="匹配规则"><a class="header-anchor" href="#匹配规则">#</a> 匹配规则</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>         foo://example.com:8042/over/there?name=ferret#nose\n         \\_/   \\______________/\\_________/ \\_________/ \\__/\n          |           |            |            |        |\n       scheme     authority       path        query   fragment\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>/</code> 匹配所有规则</li><li><code>/api</code> 匹配 path 以 <code>/api</code> 开头的路径</li></ul><h3 id="请求示例"><a class="header-anchor" href="#请求示例">#</a> 请求示例</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  url<span class="token operator">:</span> <span class="token string">&#39;/api/proxy&#39;</span><span class="token punctuation">,</span>\n  method<span class="token operator">:</span> <span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>请求发出后将会被代理到 <code>http://127.0.0.1:6001/api/proxy</code>，代理成功后可在 network 面板看到对应的信息：</p><p><img src="https://img.alicdn.com/tfs/TB1ivvqKxnaK1RjSZFBXXcW7VXa-769-407.png" alt=""></p><h2 id="访问后端地址代理前端资源"><a class="header-anchor" href="#访问后端地址代理前端资源">#</a> 访问后端地址代理前端资源</h2><p>直接访问后端服务提供的页面 url 地址，然后将页面中加载的资源代理成本地调试的资源，推荐两种方案：</p>',9),m=(0,e.Wm)("li",null,[(0,e.Wm)("strong",null,"推荐"),(0,e.Uk)("：通过 icejs 插件 "),(0,e.Wm)("a",{href:"/docs/guide/develop/plugin-list#plugin-smart-debug"},"build-plguin-smart-debug")],-1),b={href:"https://github.com/yize/xswitch",target:"_blank",rel:"noopener noreferrer"},g=(0,e.Uk)("chrome 插件 xswitch"),k={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[t,(0,e.Wm)("p",null,[p,l,r,o,c,(0,e.Wm)("a",i,[u,(0,e.Wm)(a)]),d]),h,(0,e.Wm)("ol",null,[m,(0,e.Wm)("li",null,[(0,e.Wm)("a",b,[g,(0,e.Wm)(a)])])])],64)}}}}]);